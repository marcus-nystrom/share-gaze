"""
 by Henrik Garde, Marcus Nystrom & Diederick Niehorster, Humanities Lab, LU, 2015
 
 This script do xy-tracking in one thread and xy-casting (send+receive) 
 in another thread by using the  - uses the MultiCast and the xGazeCastThread class found in the
 CastThread module. 

 In the main thread a loop timed by a Psychopy win-flip or a sleep is polling 
 for track-data (ET-xy), sending cast-data (other client xy and server intstuctions).
 
 In this script Psychopy is used to visualize the xy-sharing with other clients.
 
 Made for running on client(s) in Digital Classroom (or other closed network) 
 and share data among all. If executed with xyWaitForStartSignal = True 
 it will enter a pending mode = waiting for a msg with 'start' from a 'server'.
 (use server script in this folder to broadcast a 'start' msg) 
 (see parameters below)
 
 PS: This code was tested from Python IDE + Terminal rather than in PsychoPy

 You may want to run this from a cmd prompt with arguments:
 $ python client_xyCastThread.py sim 5 1 0 1 0 0 1000

 Arguments: 1 and 0 is converted to True and False
 [0] is always script's .py filename
 [1] xySource = sim (default)
        What xy source to use: a specific class to simulate or eyetrack xy data
       'sim': Data is simulated. Default x-pendling edge-to-edge ('pingpong'). Or use 'sinus'
       'iView': xy retrieved from SMI Eyetracker via iView
 [2] xySendOneOutOf = 5 (default)
       Should be > 1 even if sharing (sending to) only 1 client in network
       '0' means skip multicasting (no sharing): Used to check the a light execution (should run smoothly)
 [3] xyReceiveOwnData = 1 (default)
       Used for testing fastest possible communication (with self)
 [4] xyWaitForStartSignal = 0 (default)
       1: Sending is pending until a 'start' msg from server is received
 [5] xyWinFlipLoop = 1
       False: time.sleep(0.02) is active in loop = 50 Hz
       1: Use Psychopy window to pace data retrieval loop
       0: Use Sleep to pace data retrieval loop
 [6] xyDoVisualize = 1
       True: Visualizes incoming data in psychopy window
       False: No drawing to psychopy window whatsoever
 [7] xyMaxLoops = 1000
       0: infinitely, until escape pressed or until stop message received

 Files with index and timing is always produced

 sample arg:
 sim 10 1 0 1 1 1000  = simulation: send each 10nd xy to self (default)
 sim 10 0 1 1 1 1000  = simulation: Server must run server_CastThread.py after. Includes a time sync and client start
 sim 0 0 0 0 1 1000  = simulation: Send nothing, no window
 iView 5 1 1 1 1 1000  = simulation: iView must run. Server must run a time sync and start clients
"""
from psychopy import core, event, visual, monitors
import CastThread
import time
import datetime
import socket
import win32api
import numpy as np
import sys
import os

###############################################################################
# Use default parameters or accept input from the command line
###############################################################################
xySource = 'sim'              # [1] 'sim': xy is simulated;
                              #     'iView': xy is generated by iView eye tracker.
xySendOneOutOf = 10           # [2] Should be > 1 even if sharing (sending to) only 1 client in network
                              #     '0' means skip sending: Used to check the a light execution (should run smoothly)
xyReceiveOwnData = True       # [3] Used for testing fastest possible communication (with self)
xyWaitForStartSignal = False  # [4] True: Multicast is pending until a 'start' msg is received. See Server_CastThread.py
xyWinFlipLoop = True          # [5] False: time.sleep(0.017) is active in loop = 60 Hz
xyDoVisualize = 0             # [6] True: Visualizes incoming data in psychopy window
xyMaxLoops = 1000             # [7] 0: infinitely or until escape pressed

skip_calib = True
exceptCount = 0


# Overwrite above default parameters if arguments are passed via command line:
try:
    #  argv[0] is filename of this script!
    if len(sys.argv) > 1:
        xySource = sys.argv[1]
    if len(sys.argv) > 2:
        xySendOneOutOf = int(sys.argv[2])
    if len(sys.argv) > 3:
        xyReceiveOwnData = int(sys.argv[3]) == 1
    if len(sys.argv) > 4:
        xyWaitForStartSignal = int(sys.argv[4]) == 1
    if len(sys.argv) > 5:
        xyWinFlipLoop = int(sys.argv[5]) == 1
    if len(sys.argv) > 6:
        xyDoVisualize = int(sys.argv[6]) == 1
    if len(sys.argv) > 7:
        xyMaxLoops = int(sys.argv[7])
except Exception:  # 
    print('Doh! Unexpected Argument(s)')
#http://www.tutorialspoint.com/python/python_command_line_arguments.htm

###############################################################################
# Setup PsychoPy monitor, screen properties, and objects you need for drawing
###############################################################################    

this_dir = os.path.abspath(os.path.dirname(__file__))  # os.getcwd()
os.chdir(this_dir)

mon = monitors.Monitor('default')
mon.setWidth(47.5)  # Width of screen (cm)
mon.setDistance(65)  # Distance eye monitor (cm)
screenSize = [1680, 1050]  # 'debug';: 800,600'

# Create window, text and dot for Simulation:
win = visual.Window(
    size=screenSize,
    fullscr=xyWinFlipLoop,
    color=(0.5, 0.5, 0.5),
    units='norm')
if xyDoVisualize:
    instruction_text = visual.TextStim(win, text='', wrapWidth=0.6, height=0.05)
    # Create own dot
    dotStim = visual.DotStim(win, dotSize=10, fieldSize=(0, 0))

text = visual.TextStim(win, text='me')

# Create lists for dots and texts representing incoming clients' xy:
ip_i_list = []
if xyDoVisualize:
    dots = []
    texts = []
    # PS: make an empty list and do not need to add list items when running (new IP[3]s arrive)
    for i in range(0, 30):
        dots.append(visual.GratingStim(win, color='black', tex=None, mask='circle', size=0.2))
        texts.append(visual.TextStim(win, text='', height=0.2))


###############################################################################
# Samples simulated or generated by eye tracker?
###############################################################################  
# Generate y-position from IP adress' last number
# x-values will then appear 'alined according to senders ip-address' on receiving/monitoring site
my_ip = UDP_IP_LOCAL = socket.gethostbyname(socket.gethostname())
my_ip_tokens = my_ip.split('.')

# Track x,y
if xySource == 'iView':
    xyTracking = CastThread.iViewEyeTrack(mon, screenSize, calib_skip=skip_calib)
    if xyDoVisualize:
        instruction_text.setText('Eyetracking via iView')
elif xySource == 'ixxx':  ## TODO: add more ET sdk!
    xyTracking = CastThread.xSmiEyeTrack()
else:
    # 'sim' or invalid
    xySource = 'sim'
    xyTracking = CastThread.simTrack()
    if xyDoVisualize:
        instruction_text.setText('Simulated xy tracking: ' + str(xyMaxLoops) + ' Ping Pong')


###############################################################################
# Inidialize classes and start to generate samples
############################################################################### 
# Multicast xy and Listen (UDP)
xyCasting = CastThread.MultiCast(my_ip)
xyCasting.setReceiveOwn(xyReceiveOwnData)
# start data receiving thread
xyCasting.start()

# Start eye tracker and sent TTL trigger
if xyDoVisualize:
    instruction_text.draw()
    dotStim.pos = ((0, 0.1))
    dotStim.draw()
win.flip()
time.sleep(3)

xyTracking.start_recording()



###############################################################################
# Inidialize classes and start to generate samples
############################################################################### 
color_changed = False
state_flag = 0

# Time stamp for Starting this exp is overwritten if xyWaitForStartSignal is True!
time_start = datetime.datetime.now()
time_stamps = []  # Used for logging all received messages.

i = 0 # keep track of the number of loops 
runloop = True
key_pressed = False

while runloop and not key_pressed:

    # Retrieve own x,y from ET or simulated ET:
    state, x, y = xyTracking.next()

    # Draw own dot directly after it was shown
    if xyDoVisualize:
        dotStim.pos = ((x, y))
        text.pos = (0, 0.1)
        #dotStim.color *= state  # inverse on state change (1,-1)
        dotStim.draw()

    # Multicast the generated data (depends of desired send rate)
    if not xyWaitForStartSignal:
        if xySendOneOutOf > 0:  # '0' means skip all
            if i % xySendOneOutOf == 0:
                xyCasting.send(xyTracking.nextMsg())
        i += 1
        
    # Break if the maximum number of loops has been reached
    if i > xyMaxLoops:
        runloop = False
    
    # Get all the received available data from a ring buffer
    allData = xyCasting.consumeAll()
    ip_is = []
    # Receive:
    for data, addr, time_arrive in allData:
        # if starts with digit, it is a number
        if data[0].isdigit() or (data[0] in ('-','+') and data[1].isdigit()):
            
            # Unpack received data
            xy = data.split(',')
            ip_tokens = addr[0].split('.')  #HG

            ip_i = int(ip_tokens[3])
            ip_is.append(ip_i)
            if xyDoVisualize:
                state_flag = float(xy[4])
                # Plot in PsychoPy window: received x,y, and flag in senders color (IP address based)
                texts[ip_i].pos = (float(xy[0]), float(xy[1]) + 0.03)
                dots[ip_i].pos =  (float(xy[0]), float(xy[1]))

            # Add all arrivals to list
            time_sent = float(xy[2])
            i_sent = int(xy[3])
            time_stamps.append([i_sent, time_sent, time_arrive, ip_i])  

        elif data[0:5] == 'retur':
            # A travel time measure is initiated by Server on this LAN.
            # All clients should reply by multicasting 'echo' + the msg_index contained in the package
            # Used for clock sync and latency measurements
            msg = data.split(',')
            message = ','.join(('echo!', msg[2]))
            xyCasting.send(message)
        elif data[0:5] == 'echo!':
            # See server_CastThread.py (server script) to see how 'echo' msg is logged by server.
            # don't process it here
            pass
        elif data[0:5] == 'sync!':
            msg = data.split(',')
            time_sync = float(msg[1])
            time_sync = datetime.datetime.utcfromtimestamp(time_sync)
            win32api.SetSystemTime(time_sync.year,
                                   time_sync.month,
                                   0,
                                   time_sync.day,
                                   time_sync.hour,
                                   time_sync.minute,
                                   time_sync.second,
                                   time_sync.microsecond//1000)
        elif data[0:5] == 'start':
            xyWaitForStartSignal = False
            time_start = datetime.datetime.now()

        elif data[0:5] == 'pause':
            xyWaitForStartSignal = True
        elif data[0:5] == 'stop!':
            xyWaitForStartSignal = True
            runloop = False
        elif data[0:5] == 'done!':
            # msg from another client signalling it is done
            # See server_CastThread.py (server script) to see how 'done' msg is logged by server.
            # don't process it here
            pass
        else:
            # ignore unknown message
            # e.g. ET_EST shows up here when claling stop on the multiCast class
            pass
        
    
    # check if we got new clients, if so, give them 
    if ip_is:
        for ipi in ip_is:
            if not ipi in ip_i_list:
                ip_i_list.append(ipi)
                # and set text and dot color
#                if xyDoVisualize:
#                    dots[ipi].color = CastThread.get26colors(ipi)
#                    texts[ipi].setText(ipi)
    
    # Draw even if not receiving data in every loop
    if ip_i_list and xyDoVisualize:
        for ipi in ip_i_list:
            texts[ipi].draw()
            dots[ipi].draw()

    if xyWinFlipLoop:
        if xyWaitForStartSignal and xyDoVisualize:
            instruction_text.setText('Ready, steady...')
            instruction_text.draw()
        win.flip()
    else:
        time.sleep(0.017)  # = 1/60 sec
    
    
    # Quit program if someone pressed escape (psychopy event)
    keyname = event.getKeys(keyList=['escape'])
    if keyname:
        key_pressed = True


###############################################################################
# Now we're done and data are saved
############################################################################### 

print('Exceptin counter: ', exceptCount)

# Say ciao
if xyDoVisualize:
    instruction_text.setText('Saving data...')
    instruction_text.draw()
    dotStim.pos = ((0, 0.1))
    dotStim.draw()
win.flip()


win.close()

# Stop eye tracker after 1 second
core.wait(1)
xyTracking.stop_recording()
xyTracking.disconnect()

# Compose file name and save data
time_start = datetime.datetime.now()
et_result_folder = ''.join(('Results',
                            str(time_start.year) +
                            str(time_start.month).zfill(2)
                            + str(time_start.day).zfill(2),
                            '_DC',
                            str(my_ip_tokens[3]).zfill(2)))

et_result_path = os.sep.join((this_dir, et_result_folder))
if not os.path.exists(et_result_path):
    os.makedirs(et_result_path)

argList = '-'.join([str(a) for a in sys.argv[1:]])
my_ip_int = int(my_ip.split('.')[3])
if not my_ip_int in ip_i_list:
    # don't forget to count oneself in the number of computers
    ip_i_list.append(my_ip_int)
ipCount = str(len(ip_i_list)).zfill(2)
et_result_filename = ''.join(('multicast_',
                              str(time_start.year) +
                              str(time_start.month).zfill(2) +
                              str(time_start.day).zfill(2) +
                              str(time_start.hour).zfill(2) +
                              str(time_start.minute).zfill(2) +
                              str(time_start.second).zfill(2),
                              '_DC',
                              str(my_ip_tokens[3]).zfill(2),
                              '-',
                              ipCount,
                              '.',
                              argList,
                              '.txt'))  # MN

et_result_filepath = os.sep.join((et_result_path, et_result_filename))

if len(time_stamps) > 0:
    time_stamps = np.array(time_stamps)
    colHeader = 'index_sent, time_sent, time_arrive, ip_index'
    np.savetxt(et_result_filepath, time_stamps, delimiter=",", fmt=['%d', '%.18e', '%.18e', '%d'], header=colHeader)  # MN
else:
    # create empty file
    open(et_result_filepath,'a').close()
    
time.sleep(10) # Make sure its enough time to save the data
###############################################################################
# Send 'done' message to the server to signal that you're done
############################################################################### 

xyCasting.send('done!')

# stop reading thread
xyCasting.stop()
xyCasting.clean_up()

core.quit()
